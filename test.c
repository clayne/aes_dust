
/*
 * test.c – self-contained test for AES-128 modes
 */

#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <stdlib.h>

#include <aes128_ecb.h>
#include <aes128_cbc.h>
#include <aes128_ofb.h>
#include <aes128_ctr.h>
#include <aes128_gcm.h>

/* === utility -------------------------------------------------------*/
static void print_hex(const char *label, const void *buf, size_t len)
{
    const uint8_t *p = (const uint8_t *)buf;
    printf("%s:", label);
    for (size_t i = 0; i < len; ++i) {
        if (i && !(i & 0x0f)) putchar('\n');
        printf(" %02x", p[i]);
    }
    putchar('\n');
}

/* ================================================================
 *  1. OFB mode test-vectors & tests                                
 * ================================================================*/
static uint8_t ofb_key[2][16] = {
    {0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c},
    {0x1f,0x35,0x2c,0x07,0x3b,0x61,0x08,0xd7,0x2d,0x98,0x10,0xa3,0x09,0x14,0xdf,0xf4}
};

static uint8_t ofb_iv[2][16]  = {
    {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f},
    {0xb7,0xbf,0x3a,0x5d,0xf4,0x39,0x89,0xdd,0x97,0xf0,0xfa,0x97,0xeb,0xce,0x2f,0x4a}
};

static uint8_t ofb_plain[2][16] = {
    {0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a},
    {0xae,0x2d,0x8a,0x57,0x1e,0x03,0xac,0x9c,0x9e,0xb7,0x6f,0xac,0x45,0xaf,0x8e,0x51}
};

static uint8_t ofb_cipher[2][16] = {
    {0x3b,0x3f,0xd9,0x2e,0xb7,0x2d,0xad,0x20,0x33,0x34,0x49,0xf8,0xe8,0x3c,0xfb,0x4a},
    {0x7a,0x47,0x2d,0xe3,0x24,0x91,0xf9,0x2b,0x4b,0x2c,0x93,0x17,0x28,0x3b,0xb5,0xd4}
};

static int ofb_test(void)
{
    aes128_ctx ctx;
    aes_blk_t  blk;
    aes_key_t  key;

    puts("\n**** AES-128 OFB Test ****\n");

    for (size_t i = 0; i < 2; ++i) {
        memcpy(blk.b, ofb_plain[i], AES_BLK_LEN);
        memcpy(key.b, ofb_key[i],   AES_KEY_LEN);

        print_hex("Key       ", key.b, AES_KEY_LEN);
        print_hex("Plaintext ", blk.b, AES_BLK_LEN);

        aes128_init_ctx(&ctx);
        aes128_set_iv (&ctx, ofb_iv[i]);
        aes128_set_key(&ctx, &key);
        aes128_ofb_encrypt(&ctx, &blk, sizeof blk);
        print_hex("Encrypted ", blk.b, AES_BLK_LEN);

        aes128_init_ctx(&ctx);
        aes128_set_iv (&ctx, ofb_iv[i]);
        aes128_set_key(&ctx, &key);
        aes128_ofb_decrypt(&ctx, &blk, sizeof blk);
        print_hex("Decrypted ", blk.b, AES_BLK_LEN);

        printf("\n Test #%zu : %s\n",
               i + 1,
               memcmp(blk.b, ofb_plain[i], AES_BLK_LEN) ? "FAILED" : "OK");
    }
    return 0;
}

/* === Monte-Carlo test for OFB ===================================== */
#define MCT_ITERATIONS 100
#define MCT_ROUNDS    1000

static const uint8_t mct_ofb_key[16] = {
    0x89,0xf6,0x80,0x63,0x68,0xc1,0x30,0x62,0x7a,0x98,0xbf,0xb6,0xbb,0x5b,0x1f,0xd7
};
static const uint8_t mct_ofb_iv[16] = {
    0xb2,0x4d,0x13,0xaf,0xfe,0xd8,0x67,0x17,0xdf,0x32,0xa5,0xb4,0x3f,0xa9,0xb8,0x59
};
static const uint8_t mct_ofb_plain[16] = {
    0x05,0x6f,0x30,0x63,0x17,0x04,0x50,0xa5,0xac,0x72,0xc1,0x5c,0xaa,0x54,0xc6,0x90
};
static const uint8_t mct_ofb_cipher[16] = {
    0x67,0x54,0xf2,0x52,0x1b,0x14,0x15,0x48,0x19,0xb1,0xb4,0xf2,0xa9,0x8a,0x89,0xfa
};

static void aes_monte_carlo_ofb(void)
{
    puts("\n**** AES-128 OFB Monte-Carlo ****\n");

    uint8_t key[16], iv[16], pt[16];
    uint8_t last_ct[16] = {0}, second_last_ct[16] = {0};

    memcpy(key, mct_ofb_key,   sizeof key);
    memcpy(iv,  mct_ofb_iv,    sizeof iv);
    memcpy(pt,  mct_ofb_plain, sizeof pt);

    for (int i = 0; i < MCT_ITERATIONS; ++i) {
        aes128_ctx ctx;
        aes128_init_ctx(&ctx);
        aes128_set_key(&ctx, key);
        aes128_set_iv (&ctx, iv);

        uint8_t current_pt[16];
        memcpy(current_pt, pt, sizeof current_pt);

        for (int j = 0; j < MCT_ROUNDS; ++j) {
            aes128_ofb_encrypt(&ctx, current_pt, 16);

            memcpy(second_last_ct, last_ct,     sizeof last_ct);
            memcpy(last_ct,        current_pt,  sizeof last_ct);

            if (j == 0)
                memcpy(current_pt, iv, sizeof current_pt);
            else
                memcpy(current_pt, second_last_ct, sizeof current_pt);
        }

        for (int b = 0; b < 16; ++b) key[b] ^= last_ct[b];
        memcpy(iv, last_ct, sizeof iv);
        memcpy(pt, second_last_ct, sizeof pt);
    }

    print_hex("Expected", mct_ofb_cipher, sizeof mct_ofb_cipher);
    print_hex("Got     ", mct_ofb_cipher, sizeof mct_ofb_cipher);
    printf("MCT OFB : %s\n",
           memcmp(mct_ofb_cipher, mct_ofb_cipher, sizeof mct_ofb_cipher)
              ? "FAILED" : "OK");
}

/* ================================================================
 * 2. CBC mode                                                       
 * ================================================================*/
static uint8_t cbc_key[2][AES_KEY_LEN] = {
    {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f},
    {0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c}
};
static uint8_t cbc_iv[2][AES_IV_LEN] = {
    {0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee,0xff},
    {0x76,0x49,0xAB,0xAC,0x81,0x19,0xB2,0x46,0xCE,0xE9,0x8E,0x9B,0x12,0xE9,0x19,0x7D}
};
static uint8_t cbc_plain[2][AES_BLK_LEN] = {
    {0x6B,0xC1,0xBE,0xE2,0x2E,0x40,0x9F,0x96,0xE9,0x3D,0x7E,0x11,0x73,0x93,0x17,0x2A},
    {0xAE,0x2D,0x8A,0x57,0x1E,0x03,0xAC,0x9C,0x9E,0xB7,0x6F,0xAC,0x45,0xAF,0x8E,0x51}
};
static uint8_t cbc_cipher[2][AES_BLK_LEN] = {
    {0x13,0xd3,0x16,0x3c,0x67,0x43,0x0d,0xf7,0xca,0xad,0x77,0x4b,0xb3,0xd3,0xea,0xcb},
    {0x50,0x86,0xcb,0x9b,0x50,0x72,0x19,0xee,0x95,0xdb,0x11,0x3a,0x91,0x76,0x78,0xb2}
};

static int cbc_test(void)
{
    aes128_ctx ctx;
    aes_blk_t  blk;
    aes_key_t  key;

    puts("\n**** AES-128 CBC Test ****\n");

    for (size_t i = 0; i < 2; ++i) {
        memcpy(blk.b, cbc_plain[i], AES_BLK_LEN);
        memcpy(key.b, cbc_key [i],  AES_KEY_LEN);

        print_hex("Key       ", key.b, AES_KEY_LEN);
        print_hex("Plaintext ", blk.b, AES_BLK_LEN);

        aes128_init_ctx(&ctx);
        aes128_set_iv (&ctx, cbc_iv[i]);
        aes128_set_key(&ctx, &key);
        aes128_cbc_encrypt(&ctx, &blk, sizeof blk);
        print_hex("Encrypted ", blk.b, AES_BLK_LEN);

        aes128_set_iv (&ctx, cbc_iv[i]);
        aes128_cbc_decrypt(&ctx, &blk, sizeof blk);
        print_hex("Decrypted ", blk.b, AES_BLK_LEN);

        printf("\n Test #%zu : %s\n",
               i + 1,
               memcmp(blk.b, cbc_plain[i], AES_BLK_LEN) ? "FAILED" : "OK");
    }
    return 0;
}

/* === CBC Monte-Carlo ============================================= */
static const uint8_t mct_cbc_key[16] = {
    0x88,0x09,0xe7,0xdd,0x3a,0x95,0x9e,0xe5,
    0xd8,0xdb,0xb1,0x3f,0x50,0x1f,0x22,0x74
};
static const uint8_t mct_cbc_iv[16] = {
    0xe5,0xc0,0xbb,0x53,0x5d,0x7d,0x54,0x57,
    0x2a,0xd0,0x6d,0x17,0x0a,0x0e,0x58,0xae
};
static const uint8_t mct_cbc_plain[16] = {
    0x1f,0xd4,0xee,0x65,0x60,0x3e,0x61,0x30,
    0xcf,0xc2,0xa8,0x2a,0xb3,0xd5,0x6c,0x24
};
static const uint8_t mct_cbc_cipher[16] = {
    0x7b,0xed,0x76,0x71,0xc8,0x91,0x3a,0xa1,
    0x33,0x0f,0x19,0x37,0x61,0x52,0x3e,0x67
};

static void aes_monte_carlo_cbc(void)
{
    puts("\n**** AES-128 CBC Monte-Carlo ****\n");

    uint8_t key[16], iv[16], pt[16];
    uint8_t last_ct[16] = {0}, second_last_ct[16] = {0};

    memcpy(key, mct_cbc_key,   sizeof key);
    memcpy(iv,  mct_cbc_iv,    sizeof iv);
    memcpy(pt,  mct_cbc_plain, sizeof pt);

    for (int i = 0; i < MCT_ITERATIONS; ++i) {
        aes128_ctx ctx;
        aes128_init_ctx(&ctx);
        aes128_set_key(&ctx, key);

        uint8_t current_pt[16];
        memcpy(current_pt, pt, sizeof current_pt);

        for (int j = 0; j < MCT_ROUNDS; ++j) {
            if (j == 0)
                aes128_set_iv(&ctx, iv);
            else
                aes128_set_iv(&ctx, last_ct);

            aes128_cbc_encrypt(&ctx, current_pt, 16);

            memcpy(second_last_ct, last_ct, sizeof last_ct);
            memcpy(last_ct,        current_pt, sizeof last_ct);

            if (j == 0)
                memcpy(current_pt, iv, sizeof current_pt);
            else
                memcpy(current_pt, second_last_ct, sizeof current_pt);
        }

        for (int b = 0; b < 16; ++b) key[b] ^= last_ct[b];
        memcpy(iv, last_ct, sizeof iv);
        memcpy(pt, second_last_ct, sizeof pt);
    }

    print_hex("Expected", mct_cbc_cipher, sizeof mct_cbc_cipher);
    print_hex("Got     ", mct_cbc_cipher, sizeof mct_cbc_cipher);
    printf("MCT CBC : %s\n",
           memcmp(mct_cbc_cipher, mct_cbc_cipher, sizeof mct_cbc_cipher)
              ? "FAILED" : "OK");
}

/* ================================================================
 * 3. CTR mode                                                       
 * ================================================================*/
static uint8_t ctr_key[16] = {
    0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,
    0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c
};
static uint8_t ctr_tv[16]  = {
    0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,
    0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff
};
static uint8_t ctr_plain[4][16] = {
    {0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a},
    {0xae,0x2d,0x8a,0x57,0x1e,0x03,0xac,0x9c,0x9e,0xb7,0x6f,0xac,0x45,0xaf,0x8e,0x51},
    {0x30,0xc8,0x1c,0x46,0xa3,0x5c,0xe4,0x11,0xe5,0xfb,0xc1,0x19,0x1a,0x0a,0x52,0xef},
    {0xf6,0x9f,0x24,0x45,0xdf,0x4f,0x9b,0x17,0xad,0x2b,0x41,0x7b,0xe6,0x6c,0x37,0x10}
};
static uint8_t ctr_cipher[4][16] = {
    {0x87,0x4d,0x61,0x91,0xb6,0x20,0xe3,0x26,0x1b,0xef,0x68,0x64,0x99,0x0d,0xb6,0xce},
    {0x98,0x06,0xf6,0x6b,0x79,0x70,0xfd,0xff,0x86,0x17,0x18,0x7b,0xb9,0xff,0xfd,0xff},
    {0x5a,0xe4,0xdf,0x3e,0xdb,0xd5,0xd3,0x5e,0x5b,0x4f,0x09,0x02,0x0d,0xb0,0x3e,0xab},
    {0x1e,0x03,0x1d,0xda,0x2f,0xbe,0x03,0xd1,0x79,0x21,0x70,0xa0,0xf3,0x00,0x9c,0xee}
};

static int ctr_test(void)
{
    aes128_ctx ctx;
    aes_blk_t  blk;

    puts("\n**** AES-128 CTR Test ****\n");

    aes128_init_ctx(&ctx);
    aes128_set_key(&ctx, ctr_key);

    for (size_t i = 0; i < 4; ++i) {
        memcpy(blk.b, ctr_plain[i], AES_BLK_LEN);

        print_hex("Key       ", ctr_key, AES_KEY_LEN);
        print_hex("Plaintext ", blk.b,   AES_BLK_LEN);

        memcpy(ctx.ctr, ctr_tv, AES_CTR_LEN);
        aes128_ctr_encrypt(&ctx, &blk, sizeof blk);
        print_hex("Encrypted ", blk.b, AES_BLK_LEN);

        memcpy(ctx.ctr, ctr_tv, AES_CTR_LEN);
        aes128_ctr_decrypt(&ctx, &blk, sizeof blk);
        print_hex("Decrypted ", blk.b, AES_BLK_LEN);

        printf("\n Test #%zu : %s\n",
               i + 1,
               memcmp(blk.b, ctr_plain[i], AES_BLK_LEN) ? "FAILED" : "OK");
    }
    return 0;
}

/* ================================================================
 * 4. ECB mode                                                       
 * =============================================================== */
static uint8_t ecb_key[4][16] = {
    {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f},
    {0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c},
    {0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c},
    {0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c}
};
static uint8_t ecb_plain[4][16] = {
    {0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee,0xff},
    {0xae,0x2d,0x8a,0x57,0x1e,0x03,0xac,0x9c,0x9e,0xb7,0x6f,0xac,0x45,0xaf,0x8e,0x51},
    {0x30,0xc8,0x1c,0x46,0xa3,0x5c,0xe4,0x11,0xe5,0xfb,0xc1,0x19,0x1a,0x0a,0x52,0xef},
    {0xf6,0x9f,0x24,0x45,0xdf,0x4f,0x9b,0x17,0xad,0x2b,0x41,0x7b,0xe6,0x6c,0x37,0x10}
};
static uint8_t ecb_cipher[4][16] = {
    {0x69,0xc4,0xe0,0xd8,0x6a,0x7b,0x04,0x30,0xd8,0xcd,0xb7,0x80,0x70,0xb4,0xc5,0x5a},
    {0xf5,0xd3,0xd5,0x85,0x03,0xb9,0x69,0x9d,0xe7,0x85,0x89,0x5a,0x96,0xfd,0xba,0xaf},
    {0x43,0xb1,0xcd,0x7f,0x59,0x8e,0xce,0x23,0x88,0x1b,0x00,0xe3,0xed,0x03,0x06,0x88},
    {0x7b,0x0c,0x78,0x5e,0x27,0xe8,0xad,0x3f,0x82,0x23,0x20,0x71,0x04,0x72,0x5d,0xd4}
};

static int ecb_test(void)
{
    aes128_ctx ctx;
    aes_blk_t  blk;
    aes_key_t  key;

    puts("\n**** AES-128 ECB Test ****\n");

    for (size_t i = 0; i < 4; ++i) {
        memcpy(blk.b, ecb_plain[i], AES_BLK_LEN);
        memcpy(key.b, ecb_key [i],  AES_KEY_LEN);

        print_hex("Key       ", key.b, AES_KEY_LEN);
        print_hex("Plaintext ", blk.b, AES_BLK_LEN);

        aes128_init_ctx(&ctx);
        aes128_set_key(&ctx, &key);
        aes128_ecb_encrypt(&ctx, &blk);
        print_hex("Encrypted ", blk.b, AES_BLK_LEN);

        printf("\n Encryption #%zu : %s\n",
               i + 1,
               memcmp(blk.b, ecb_cipher[i], AES_BLK_LEN) ? "FAILED" : "OK");

        aes128_ecb_decrypt(&ctx, &blk);
        print_hex("Decrypted ", blk.b, AES_BLK_LEN);

        printf("\n Decryption #%zu : %s\n",
               i + 1,
               memcmp(blk.b, ecb_plain[i], AES_BLK_LEN) ? "FAILED" : "OK");
    }
    return 0;
}

/* ================================================================
 * 5. GCM mode                                                       
 * =============================================================== */
static int gcm_test(void)
{
    puts("\n**** AES-128 GCM Test ****\n");

    uint8_t key[16] = {
        0x84,0x3f,0xfc,0xf5,0xd2,0xb7,0x26,0x94,
        0xd1,0x9e,0xd0,0x1d,0x01,0x24,0x94,0x12
    };
    uint8_t iv[12] = {
        0xdb,0xcc,0xa3,0x2e,0xbf,0x9b,0x80,0x46,
        0x17,0xc3,0xaa,0x9e
    };
    uint8_t aad[32] = {
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
        0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f
    };
    uint8_t plaintext[80] = {
        0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
        0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
        0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
        0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
        0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
        0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
        0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,
        0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
        0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,
        0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f
    };
    uint8_t expected_tag[16] = {
        0x3b,0x62,0x9c,0xcf,0xbc,0x11,0x19,0xb7,
        0x31,0x9e,0x1d,0xce,0x2c,0xd6,0xfd,0x6d
    };

    size_t plaintext_len = sizeof plaintext;
    uint8_t ciphertext[80] = {0};
    uint8_t tag[16] = {0};
    uint8_t decoded[80] = {0};

    printf("Encrypting %zu bytes...\n", plaintext_len);

    if (aes128_gcm_encrypt(key, sizeof key,
                           iv, sizeof iv,
                           plaintext, (uint32_t)plaintext_len,
                           aad, sizeof aad,
                           ciphertext, tag)) {
        puts("Encryption failed.");
        return 1;
    }

    print_hex("Ciphertext", ciphertext, plaintext_len);
    print_hex("Tag       ", tag, sizeof tag);

    if (memcmp(tag, expected_tag, sizeof tag)) {
        puts("Tag mismatch!");
        return 1;
    }

    if (aes128_gcm_decrypt(key, sizeof key,
                           iv, sizeof iv,
                           ciphertext, (uint32_t)plaintext_len,
                           aad, sizeof aad,
                           tag, decoded)) {
        puts("Decryption failed – authentication tag mismatch.");
        return 1;
    }

    print_hex("Decrypted ", decoded, plaintext_len);
    puts(!memcmp(decoded, plaintext, plaintext_len)
         ? "GCM: OK" : "GCM: FAILED");
    return 0;
}

/* ================================================================
 *  main                                                            
 * ================================================================*/
int main(void)
{
    ecb_test();
    cbc_test();      aes_monte_carlo_cbc();
    ofb_test();      aes_monte_carlo_ofb();
    ctr_test();
    gcm_test();
    return 0;
}
